Old orientation: ('L', 'P', 'S')
New orientation: ('R', 'A', 'S')
print(fpg_ras.mri)
   ...: print(fpg_ras.heart)
   ...: 
ScalarImage(shape: (1, 112, 112, 44); spacing: (2.68, 2.68, 2.80); orientation: RAS+; memory: 2.1 MiB; type: intensity)
LabelMap(shape: (1, 112, 112, 44); spacing: (2.68, 2.68, 2.80); orientation: RAS+; memory: 2.1 MiB; type: label)

Out[11]: Affine array
array([[-2.68,  0.  ,  0.  ,  0.  ],
       [ 0.  , -2.68,  0.  ,  0.  ],
       [ 0.  ,  0.  ,  2.8 ,  0.  ],
       [ 0.  ,  0.  ,  0.  ,  1.  ]])

#Random affine :To simulate different positions and size of the patient within the scanner, we can use a RandomAffine transform.
#To improve visualization, we will use a 2D image and add a grid to it.
#random affine (rotates the image with grid slightly anticlock)
#random affine with zoom focusing on the heart_2

Random flip
#Flipping images is a very cheap way to perform data augmentation.
#In medical images, it's very common to flip the images horizontally.
#We can specify the dimensions indices when instantiating a RandomFlip transform.
#However,if we don't know the image orientation, we can't know which dimension
#corresponds to the lateral axis. In TorchIO, you can use anatomical
#labels instead, so that you don't need to figure out image orientation
#to know which axis you would like to flip. To make sure the transform modifies
#the image, we will use the inferior-superior (longitudinal) axis and a flip
#probability of 1. If the flipping happened along any other axis, we might not
#notice it using this visualization.


#Random elastic deformation To simulate anatomical variations in our images,
#we can apply a non-linear deformation using RandomElasticDeformation.
#As explained in the documentation, one can change the number of grid control
#points to set the deformation smoothness.
#Let's look at the effect of using few control points
#but very large displacements.

#Intensity transforms
#Intensity transforms modify only scalar images, whereas label maps are left
#as they were.

#Preprocessing (normalization)
#Rescale intensity
#We can change the intensities range of our images so that it lies within
#e.g. 0 and 1, or -1 and 1, using RescaleIntensity.

#There seem to be some outliers with very high intensity.
#We might be able to get rid of those by mapping some percentiles to our final values.

#Z-normalization
#Another common approach for normalization is forcing data points to have zero-mean
#and unit variance. We can use ZNormalization for this.

#The second mode in our distribution, corresponding to the foreground, is far from zero
#because the background contributes a lot to the mean computation.
#We can compute the stats using e.g. values above the mean only.
#Let's see if the mean is a good threshold to segment the foreground.

#The second mode is now closer to zero, as only the foreground voxels have been
#used to compute the statistics.


#Random blur
#We can use RandomBlur to smooth/blur the images. The standard deviations of the
#Gaussian kernels are expressed in mm and will be computed independently for each axis.


#Random noise
#Gaussian noise can be simulated using RandomNoise. This transform is easiest to use after
#ZNormalization, as we know beforehand that the mean and standard deviation of the input will
#be 0 and 1, respectively. If necessary, the noise mean and std can be set using the
#corresponding keyword arguments.

#Noise in MRI is actually Rician, but it is nearly Gaussian for SNR > 2 (i.e. foreground).


#MRI-specific transforms
#TorchIO includes some transforms to simulate image artifacts specific to MRI modalities.

#Random bias field (DID NOT WORK - REWORK)
#Magnetic field inhomogeneities in the MRI scanner produce low-frequency intensity distortions
#in the images, which are typically corrected using algorithms such as N4ITK.
#To simulate this artifact, we can use RandomBiasField.

#For this example, we will use an image that has been preprocessed so it's meant to be unbiased.


#k -space transforms
#MR images are generated by computing the inverse Fourier transform of the k-space, which is the signal received by the coils
#in the scanner. If the k-space is altered, an artifact will be created in the image. These artifacts are typically
# accidental, but we can use transforms to simulate them.

#Random spike
#Sometimes, signal peaks can appear in k-space. If one adds a high-energy component at e.g. 440 Hz in the spectrum of
# an audio signal, a tone of that frequency will be audible in the time domain. Similarly, spikes in k-space manifest
# as stripes in image space. They can be simulated using RandomSpike. The number of spikes doesn't affect the transform
# run time, so try adding more!

#Random ghosting
#Ghosting artifacts, caused by patient motion, can be simulated by removing every nth plane from the k-space,
# and can be generated using RandomGhosting. As with the previous transform, the number of ghosts doesn't affect
# the run time, so you can add as many as you like.


#Random motion
#If the patient moves during the MRI acquisition, motion artifacts will be present. TorchIO includes an implementation of
# Shaw et al., where the artifact is generated by filling the k-space with random rigidly-transformed versions of the
# original images and computing the inverse transform of the compound k-space.

#Computing the direct and inverse Fourier transform takes some time, so we'll use nearest neighbor interpolation to
# resample faster. Another way of cutting down the run time is using a smaller number of transforms (i.e., the patient
# moves less during acquisition time).
